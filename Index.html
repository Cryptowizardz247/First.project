<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Speed 2X - Realistic Car Drive</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        
        canvas {
            display: block;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 60px;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .control-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.7);
            border: none;
            font-size: 24px;
            touch-action: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #stats {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
        
        #title {
            position: fixed;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 28px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            pointer-events: none;
        }
        
        #view-toggle {
            position: fixed;
            bottom: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        #orientation-message {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            font-size: 24px;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
        }

        .animal {
            position: absolute;
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            pointer-events: none;
            z-index: 10;
            transition: transform 0.3s ease;
            image-rendering: crisp-edges;
        }
        
        .bird {
            position: absolute;
            width: 30px;
            height: 30px;
            background-size: contain;
            background-repeat: no-repeat;
            pointer-events: none;
            z-index: 5;
            transition: transform 0.5s ease;
            image-rendering: crisp-edges;
        }
        
        @media (orientation: portrait) {
            #orientation-message {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="orientation-message">
        Please rotate your device to landscape mode for the best experience
    </div>
    
    <div id="title">Speed 2X - Realistic Drive</div>
    <button id="view-toggle">Toggle View</button>
    <div class="controls">
        <button class="control-btn" id="leftBtn">‚óÑ</button>
        <button class="control-btn" id="upBtn">‚ñ≤</button>
        <button class="control-btn" id="downBtn">‚ñº</button>
        <button class="control-btn" id="rightBtn">‚ñ∫</button>
    </div>
    <div id="stats">
        Distance: <span id="distance">0</span>m<br>
        Speed: <span id="speed">0</span>km/h<br>
        Gear: <span id="gear">P</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Check orientation
        function checkOrientation() {
            if (window.innerHeight > window.innerWidth) {
                document.getElementById('orientation-message').style.display = 'flex';
            } else {
                document.getElementById('orientation-message').style.display = 'none';
            }
        }
        
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        checkOrientation();

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.0005);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // Skybox
        const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
        const skyTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg');
        skyTexture.encoding = THREE.sRGBEncoding;
        const skyMaterial = new THREE.MeshBasicMaterial({
            map: skyTexture,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Clouds
        const cloudGeometry = new THREE.PlaneGeometry(100, 50);
        const cloudTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/cloud.png');
        cloudTexture.encoding = THREE.sRGBEncoding;
        const cloudMaterial = new THREE.MeshLambertMaterial({
            map: cloudTexture,
            transparent: true,
            opacity: 0.7
        });
        for (let i = 0; i < 15; i++) {
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloud.position.set(
                (Math.random() - 0.5) * 1800,
                Math.random() * 100 + 50,
                (Math.random() - 0.5) * 1800
            );
            cloud.rotation.y = Math.random() * Math.PI;
            cloud.receiveShadow = true;
            scene.add(cloud);
        }

        // High-end Car
        function createLuxuryCar() {
            const car = new THREE.Group();
            
            // Main body
            const bodyGeometry = new THREE.BoxGeometry(4.5, 1.4, 2);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2a5c8b,
                shininess: 100,
                specular: 0x333333
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            car.add(body);
            
            // Roof
            const roofGeometry = new THREE.BoxGeometry(3.8, 0.3, 1.8);
            const roofMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x111111,
                shininess: 150
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 1.3;
            roof.castShadow = true;
            roof.receiveShadow = true;
            car.add(roof);
            
            // Windows
            const windowGeometry = new THREE.BoxGeometry(3.7, 0.8, 1.7);
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x80b3ff,
                transparent: true,
                opacity: 0.6,
                shininess: 120,
                specular: 0xffffff
            });
            const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
            windowMesh.position.y = 1.35;
            car.add(windowMesh);
            
            // Front details
            const frontGeometry = new THREE.BoxGeometry(0.8, 0.8, 1.8);
            const frontMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                shininess: 80
            });
            const front = new THREE.Mesh(frontGeometry, frontMaterial);
            front.position.set(2.3, 0.5, 0);
            car.add(front);
            
            // Grille
            const grilleGeometry = new THREE.BoxGeometry(0.6, 0.4, 1.6);
            const grilleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x222222,
                shininess: 50,
                specular: 0x666666
            });
            const grille = new THREE.Mesh(grilleGeometry, grilleMaterial);
            grille.position.set(2.5, 0.5, 0);
            car.add(grille);
            
            // Headlights
            const headlightGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const headlightMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffcc,
                emissive: 0xffffee,
                emissiveIntensity: 0.5
            });
            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(2.4, 0.5, 0.8);
            car.add(leftHeadlight);
            
            const rightHeadlight = leftHeadlight.clone();
            rightHeadlight.position.z = -0.8;
            car.add(rightHeadlight);
            
            // Rear details
            const rearGeometry = new THREE.BoxGeometry(0.8, 0.8, 1.8);
            const rearMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x222222,
                shininess: 80
            });
            const rear = new THREE.Mesh(rearGeometry, rearMaterial);
            rear.position.set(-2.3, 0.5, 0);
            car.add(rear);
            
            // Taillights
            const taillightGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const taillightMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff3333,
                emissive: 0xff0000,
                emissiveIntensity: 0.3
            });
            const leftTaillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
            leftTaillight.position.set(-2.4, 0.5, 0.8);
            car.add(leftTaillight);
            
            const rightTaillight = leftTaillight.clone();
            rightTaillight.position.z = -0.8;
            car.add(rightTaillight);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 32);
            const wheelMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x222222,
                shininess: 30
            });
            
            const wheelCoverGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.41, 32);
            const wheelCoverMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xaaaaaa,
                shininess: 100
            });
            
            // Front left wheel
            const flWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            flWheel.rotation.z = Math.PI / 2;
            flWheel.position.set(1.2, -0.4, 1.1);
            flWheel.castShadow = true;
            const flWheelCover = new THREE.Mesh(wheelCoverGeometry, wheelCoverMaterial);
            flWheelCover.rotation.z = Math.PI / 2;
            flWheel.add(flWheelCover);
            car.add(flWheel);
            
            // Front right wheel
            const frWheel = flWheel.clone();
            frWheel.position.z = -1.1;
            car.add(frWheel);
            
            // Rear left wheel
            const rlWheel = flWheel.clone();
            rlWheel.position.x = -1.2;
            car.add(rlWheel);
            
            // Rear right wheel
            const rrWheel = frWheel.clone();
            rrWheel.position.x = -1.2;
            car.add(rrWheel);
            
            // Exhaust pipes
            const exhaustGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 16);
            const exhaustMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x777777,
                shininess: 150
            });
            const leftExhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            leftExhaust.rotation.x = Math.PI / 2;
            leftExhaust.position.set(-2.2, 0.2, -0.6);
            car.add(leftExhaust);
            
            const rightExhaust = leftExhaust.clone();
            rightExhaust.position.z = 0.6;
            car.add(rightExhaust);
            
            // Driver
            const driverGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
            const driverMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const driver = new THREE.Mesh(driverGeometry, driverMaterial);
            driver.position.set(0, 0.8, 0);
            car.add(driver);
            
            // Steering wheel
            const steeringWheelGeometry = new THREE.TorusGeometry(0.2, 0.05, 16, 32);
            const steeringWheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const steeringWheel = new THREE.Mesh(steeringWheelGeometry, steeringWheelMaterial);
            steeringWheel.position.set(0.5, 0.8, 0.3);
            steeringWheel.rotation.z = Math.PI / 2;
            car.add(steeringWheel);
            
            return car;
        }

        const car = createLuxuryCar();
        car.position.y = 0.7;
        scene.add(car);

        // Expanded 3D Map
        const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
        const groundTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(50, 50);
        groundTexture.encoding = THREE.sRGBEncoding;
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            map: groundTexture,
            color: 0x228B22,
            shininess: 30
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        ground.receiveShadow = true;
        scene.add(ground);

        // Road network
        const roadMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x333333,
            specular: 0x222222,
            shininess: 20
        });
        
        for (let x = -900; x <= 900; x += 100) {
            const road = new THREE.Mesh(new THREE.PlaneGeometry(2000, 20), roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.set(x, 0, 0);
            road.receiveShadow = true;
            scene.add(road);
            
            // Sidewalks
            const sidewalkMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
            const sidewalk1 = new THREE.Mesh(new THREE.PlaneGeometry(2000, 5), sidewalkMaterial);
            sidewalk1.rotation.x = -Math.PI / 2;
            sidewalk1.position.set(x, 0.01, 12.5);
            sidewalk1.receiveShadow = true;
            scene.add(sidewalk1);
            
            const sidewalk2 = sidewalk1.clone();
            sidewalk2.position.z = -12.5;
            scene.add(sidewalk2);
        }
        
        for (let z = -900; z <= 900; z += 100) {
            const road = new THREE.Mesh(new THREE.PlaneGeometry(20, 2000), roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.set(0, 0, z);
            road.receiveShadow = true;
            scene.add(road);
            
            // Sidewalks
            const sidewalkMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
            const sidewalk1 = new THREE.Mesh(new THREE.PlaneGeometry(5, 2000), sidewalkMaterial);
            sidewalk1.rotation.x = -Math.PI / 2;
            sidewalk1.position.set(12.5, 0.01, z);
            sidewalk1.receiveShadow = true;
            scene.add(sidewalk1);
            
            const sidewalk2 = sidewalk1.clone();
            sidewalk2.position.x = -12.5;
            scene.add(sidewalk2);
        }

        // Road markings
        const lineGeometry = new THREE.PlaneGeometry(2, 0.2);
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        for (let x = -900; x < 900; x += 10) {
            for (let z = -900; z < 900; z += 100) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.01, z);
                scene.add(line);
            }
        }

        // Buildings
        const buildingMaterials = [
            new THREE.MeshPhongMaterial({ color: 0x8B4513 }), // Brownstone
            new THREE.MeshPhongMaterial({ color: 0x708090 }), // Slate gray
            new THREE.MeshPhongMaterial({ color: 0x4682B4 }), // Steel blue
            new THREE.MeshPhongMaterial({ color: 0xA0522D })  // Sienna
        ];
        
        for (let i = 0; i < 80; i++) {
            const width = Math.random() * 30 + 20;
            const depth = Math.random() * 30 + 20;
            const height = Math.random() * 50 + 30;
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const material = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];
            const building = new THREE.Mesh(buildingGeometry, material);
            
            building.position.set(
                (Math.random() - 0.5) * 1800,
                height / 2,
                (Math.random() - 0.5) * 1800
            );
            
            // Avoid placing buildings on roads
            if (Math.abs(building.position.x % 100) > 30 && Math.abs(building.position.z % 100) > 30) {
                building.castShadow = true;
                building.receiveShadow = true;
                
                // Add windows
                if (height > 40) {
                    const windowRows = Math.floor(height / 10);
                    const windowCols = Math.floor(width / 5);
                    
                    for (let w = 0; w < windowRows; w++) {
                        for (let c = 0; c < windowCols; c++) {
                            const windowGeometry = new THREE.PlaneGeometry(1.5, 1.5);
                            const windowMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0x3399ff,
                                transparent: true,
                                opacity: 0.7
                            });
                            const window = new THREE.Mesh(windowGeometry, windowMaterial);
                            
                            // Place windows on all sides
                            const side = Math.floor(Math.random() * 4);
                            const offsetX = (c / windowCols - 0.5) * width;
                            const offsetY = (w / windowRows - 0.3) * height + 5;
                            const offsetZ = (Math.random() - 0.5) * depth;
                            
                            if (side === 0) { // Front
                                window.position.set(offsetX, offsetY, depth/2 + 0.1);
                                window.rotation.y = 0;
                            } else if (side === 1) { // Back
                                window.position.set(offsetX, offsetY, -depth/2 - 0.1);
                                window.rotation.y = Math.PI;
                            } else if (side === 2) { // Left
                                window.position.set(-width/2 - 0.1, offsetY, offsetZ);
                                window.rotation.y = Math.PI/2;
                            } else { // Right
window.position.set(width/2 + 0.1, offsetY, offsetZ);
                                window.rotation.y = -Math.PI/2;
                            }
                            
                            building.add(window);
                        }
                    }
                }
                
                scene.add(building);
            }
        }

        // Trees
        function createTree(x, z) {
            const tree = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 6, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);
            
            // Leaves
            const leavesGeometry = new THREE.SphereGeometry(4, 16, 16);
            const leavesMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x228B22,
                transparent: true,
                opacity: 0.9
            });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 7;
            leaves.castShadow = true;
            tree.add(leaves);
            
            tree.position.set(x, 0, z);
            return tree;
        }

        // Flowers
        function createFlowerPatch(x, z) {
            const patch = new THREE.Group();
            const flowerColors = [0xFF69B4, 0xFFD700, 0x9370DB, 0xFF6347, 0x40E0D0];
            
            for (let i = 0; i < 10; i++) {
                const flower = new THREE.Group();
                
                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                const stemMaterial = new THREE.MeshPhongMaterial({ color: 0x32CD32 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.rotation.x = Math.PI / 2;
                stem.position.y = 0.25;
                flower.add(stem);
                
                // Flower head
                const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const headMaterial = new THREE.MeshPhongMaterial({ color: color });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.z = 0.5;
                flower.add(head);
                
                // Position the flower randomly in the patch
                flower.position.set(
                    (Math.random() - 0.5) * 5,
                    0,
                    (Math.random() - 0.5) * 5
                );
                flower.rotation.y = Math.random() * Math.PI * 2;
                
                patch.add(flower);
            }
            
            patch.position.set(x, 0.01, z);
            return patch;
        }

        // Add trees and flowers along roads
        for (let x = -900; x <= 900; x += 100) {
            for (let z = -950; z <= 950; z += 50) {
                if (Math.random() > 0.7) {
                    const tree = createTree(x + (Math.random() - 0.5) * 30 + 20, z);
                    scene.add(tree);
                    
                    const tree2 = createTree(x + (Math.random() - 0.5) * 30 - 20, z);
                    scene.add(tree2);
                }
                
                if (Math.random() > 0.8) {
                    const flowers = createFlowerPatch(x + (Math.random() - 0.5) * 30 + 25, z);
                    scene.add(flowers);
                    
                    const flowers2 = createFlowerPatch(x + (Math.random() - 0.5) * 30 - 25, z);
                    scene.add(flowers2);
                }
            }
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);
        
        const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
        scene.add(hemisphereLight);
        
        // Car headlights
        const carHeadlight1 = new THREE.SpotLight(0xffffcc, 1, 50, Math.PI/6, 0.5);
        carHeadlight1.position.set(2.4, 0.5, 0.8);
        carHeadlight1.target.position.set(5, 0, 0.8);
        car.add(carHeadlight1);
        car.add(carHeadlight1.target);
        
        const carHeadlight2 = carHeadlight1.clone();
        carHeadlight2.position.z = -0.8;
        carHeadlight2.target.position.z = -0.8;
        car.add(carHeadlight2);
        car.add(carHeadlight2.target);

        // Camera
        camera.position.set(0, 5, 15);
        camera.lookAt(car.position);

        // Animals in the garden
        const animals = [];
        const animalTypes = [
            { name: 'rabbit', speed: 0.5, runSpeed: 1.2, size: 0.4 },
            { name: 'deer', speed: 0.3, runSpeed: 0.8, size: 0.6 },
            { name: 'fox', speed: 0.7, runSpeed: 1.5, size: 0.5 }
        ];

        // Animal sprites (using emoji as placeholders)
        const animalSprites = {
            rabbit: 'üêá',
            deer: 'ü¶å',
            fox: 'ü¶ä'
        };

        // Create animal elements
        function createAnimals() {
            for (let i = 0; i < 15; i++) {
                const animal = document.createElement('div');
                animal.className = 'animal';
                const type = animalTypes[Math.floor(Math.random() * animalTypes.length)];
                
                // Create animal element
                animal.innerHTML = `<div style="font-size:40px;text-align:center">${animalSprites[type.name]}</div>`;
                animal.dataset.type = type.name;
                animal.dataset.size = type.size;
                
                // Random position near roads but not on them
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 1800;
                    z = (Math.random() - 0.5) * 1800;
                } while (Math.abs(x % 100) < 30 || Math.abs(z % 100) < 30);
                
                animal.dataset.x = x;
                animal.dataset.z = z;
                animal.dataset.y = 0;
                animal.dataset.speed = type.speed;
                animal.dataset.runSpeed = type.runSpeed;
                animal.dataset.direction = Math.random() * Math.PI * 2;
                animal.dataset.changeDirectionTime = Math.random() * 3000 + 2000;
                animal.dataset.lastDirectionChange = Date.now();
                animal.dataset.state = 'walking'; // walking, running
                
                document.body.appendChild(animal);
                animals.push(animal);
            }
        }

        // Birds flying in the sky
        const birds = [];
        function createBirds() {
            for (let i = 0; i < 10; i++) {
                const bird = document.createElement('div');
                bird.className = 'bird';
                
                // Create bird element
                bird.innerHTML = '<div style="font-size:30px;text-align:center">üê¶</div>';
                
                // Start position
                bird.dataset.x = (Math.random() - 0.5) * 1800;
                bird.dataset.y = Math.random() * 100 + 50;
                bird.dataset.z = (Math.random() - 0.5) * 1800;
                bird.dataset.speed = Math.random() * 0.5 + 0.5;
                bird.dataset.direction = Math.random() * Math.PI * 2;
                
                document.body.appendChild(bird);
                birds.push(bird);
            }
        }

        // Update animal positions
        function updateAnimals() {
            const now = Date.now();
            const carX = car.position.x;
            const carZ = car.position.z;
            
            animals.forEach(animal => {
                const x = parseFloat(animal.dataset.x);
                const z = parseFloat(animal.dataset.z);
                
                // Check distance to car
                const distToCar = Math.sqrt((x - carX) ** 2 + (z - carZ) ** 2);
                
                // Run away if car is close
                if (distToCar < 50 && animal.dataset.state !== 'running') {
                    animal.dataset.state = 'running';
                    animal.dataset.direction = Math.atan2(z - carZ, x - carX);
                    animal.dataset.speed = parseFloat(animal.dataset.runSpeed);
                    animal.dataset.lastDirectionChange = now;
                }
                
                // Change direction occasionally when not running
                if (animal.dataset.state === 'walking' && 
                    now - animal.dataset.lastDirectionChange > animal.dataset.changeDirectionTime) {
                    animal.dataset.direction = Math.random() * Math.PI * 2;
                    animal.dataset.changeDirectionTime = Math.random() * 3000 + 2000;
                    animal.dataset.lastDirectionChange = now;
                }
                
                // Return to walking if far enough from car
if (distToCar > 70 && animal.dataset.state === 'running') {
                    animal.dataset.state = 'walking';
                    animal.dataset.speed = parseFloat(animal.dataset.speed) * 0.5;
                }
                
                // Move animal
                animal.dataset.x = x + Math.cos(animal.dataset.direction) * animal.dataset.speed;
                animal.dataset.z = z + Math.sin(animal.dataset.direction) * animal.dataset.speed;
                
                // Keep animals within bounds
                if (animal.dataset.x > 900) {
                    animal.dataset.x = 900;
                    animal.dataset.direction = Math.PI - animal.dataset.direction;
                }
                if (animal.dataset.x < -900) {
                    animal.dataset.x = -900;
                    animal.dataset.direction = Math.PI - animal.dataset.direction;
                }
                if (animal.dataset.z > 900) {
                    animal.dataset.z = 900;
                    animal.dataset.direction = -animal.dataset.direction;
                }
                if (animal.dataset.z < -900) {
                    animal.dataset.z = -900;
                    animal.dataset.direction = -animal.dataset.direction;
                }
                
                // Avoid roads
                if (Math.abs(animal.dataset.x % 100) < 30 || Math.abs(animal.dataset.z % 100) < 30) {
                    animal.dataset.direction += Math.PI / 2;
                }
                
                // Update position on screen
                updateScreenPosition(animal);
            });
        }

        // Update bird positions
        function updateBirds() {
            birds.forEach(bird => {
                // Change direction occasionally
                if (Math.random() < 0.005) {
                    bird.dataset.direction = Math.random() * Math.PI * 2;
                }
                
                // Move bird
                bird.dataset.x = parseFloat(bird.dataset.x) + 
                    Math.cos(bird.dataset.direction) * bird.dataset.speed;
                bird.dataset.z = parseFloat(bird.dataset.z) + 
                    Math.sin(bird.dataset.direction) * bird.dataset.speed;
                
                // Random slight altitude changes
                if (Math.random() < 0.1) {
                    bird.dataset.y = Math.max(50, Math.min(150, 
                        parseFloat(bird.dataset.y) + (Math.random() - 0.5) * 5));
                }
                
                // Keep birds within bounds
                if (bird.dataset.x > 900 || bird.dataset.x < -900 || 
                    bird.dataset.z > 900 || bird.dataset.z < -900) {
                    bird.dataset.direction = Math.atan2(
                        -parseFloat(bird.dataset.z), 
                        -parseFloat(bird.dataset.x)
                    );
                }
                
                // Update position on screen
                updateScreenPosition(bird);
            });
        }

        // Convert 3D position to screen position
        function updateScreenPosition(element) {
            const vector = new THREE.Vector3(
                parseFloat(element.dataset.x),
                parseFloat(element.dataset.y || 0),
                parseFloat(element.dataset.z)
            );
            
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
            
            element.style.transform = `translate(${x}px, ${y}px)`;
            element.style.zIndex = Math.floor(vector.z * -1000);
            
            // Flip animal/bird based on direction
            if (Math.cos(element.dataset.direction) < 0) {
                element.style.transform += ' scaleX(-1)';
            }
            
            // Scale based on distance
            const scale = element.dataset.size ? 
                parseFloat(element.dataset.size) * (1 + vector.z * 0.5) : 
                (1 + vector.z * 0.5);
            element.style.transform += ` scale(${scale})`;
        }

        // Controls
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const upBtn = document.getElementById('upBtn');
        const downBtn = document.getElementById('downBtn');
        const viewToggleBtn = document.getElementById('view-toggle');
        
        let movingLeft = false;
        let movingRight = false;
        let movingUp = false;
        let movingDown = false;
        let speedX = 0;
        let speedZ = 0;
        const maxSpeed = 1.6; // 2X Faster
        const acceleration = 0.04;
        let distanceTraveled = 0;
        let gear = 'P';
        let isCockpitView = false;

        // Stats
        const distanceDisplay = document.getElementById('distance');
        const speedDisplay = document.getElementById('speed');
        const gearDisplay = document.getElementById('gear');

        // Touch controls
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movingLeft = true; });
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); movingLeft = false; });
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movingRight = true; });
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); movingRight = false; });
        upBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movingUp = true; gear = 'D'; gearDisplay.textContent = gear; });
        upBtn.addEventListener('touchend', (e) => { e.preventDefault(); movingUp = false; if(!movingDown) gear = 'N'; gearDisplay.textContent = gear; });
        downBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movingDown = true; gear = 'R'; gearDisplay.textContent = gear; });
        downBtn.addEventListener('touchend', (e) => { e.preventDefault(); movingDown = false; if(!movingUp) gear = 'N'; gearDisplay.textContent = gear; });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowLeft': movingLeft = true; break;
                case 'ArrowRight': movingRight = true; break;
                case 'ArrowUp': movingUp = true; gear = 'D'; gearDisplay.textContent = gear; break;
                case 'ArrowDown': movingDown = true; gear = 'R'; gearDisplay.textContent = gear; break;
                case 'v': toggleView(); break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowLeft': movingLeft = false; break;
                case 'ArrowRight': movingRight = false; break;
                case 'ArrowUp': movingUp = false; if(!movingDown) gear = 'N'; gearDisplay.textContent = gear; break;
                case 'ArrowDown': movingDown = false; if(!movingUp) gear = 'N'; gearDisplay.textContent = gear; break;
            }
        });

        // Toggle view (Chase/Cockpit)
        function toggleView() {
            isCockpitView = !isCockpitView;
            viewToggleBtn.textContent = isCockpitView ? "Chase View" : "Cockpit View";
        }
        
        viewToggleBtn.addEventListener('click', toggleView);

        // Game logic
        function update() {
            // X-axis movement (left/right)
            if (movingRight) {
                speedX = Math.min(speedX + acceleration, maxSpeed);
                car.rotation.y = -Math.PI / 10;
            } else if (movingLeft) {
                speedX = Math.max(speedX - acceleration, -maxSpeed);
                car.rotation.y = Math.PI / 10;
            } else {
                speedX *= 0.92;
                car.rotation.y = 0;
            }

            // Z-axis movement (forward/backward)
            if (movingUp) {
                speedZ = Math.max(speedZ - acceleration, -maxSpeed);
            } else if (movingDown) {
                speedZ = Math.min(speedZ + acceleration, maxSpeed);
            } else {
                speedZ *= 0.92;
            }

            car.position.x += speedX;
            car.position.z += speedZ;
            distanceTraveled += Math.sqrt(speedX * speedX + speedZ * speedZ);

            // Keep car within bounds
            if (car.position.x > 900) {
                car.position.x = 900;
                speedX = 0;
            }
            if (car.position.x < -900) {
                car.position.x = -900;
                speedX = 0;
            }
            if (car.position.z > 900) {
                car.position.z = 900;
                speedZ = 0;
            }
            if (car.position.z < -900) {
                car.position.z = -900;
                speedZ = 0;
            }

            // Camera follows car with slight delay for smoother movement
            if (isCockpitView) {
                // Cockpit view (inside car)
                camera.position.x = car.position.x;
                camera.position.y = car.position.y + 1.5;
                camera.position.z = car.position.z - 2;
                camera.rotation.y = car.rotation.y;
            } else {
                // Chase view (behind car)
                const targetCameraX = car.position.x;
                const targetCameraY = 5 + Math.abs(speedZ) * 3;
                const targetCameraZ = car.position.z + 15 - Math.abs(speedX) * 5;
                
                camera.position.x += (targetCameraX - camera.position.x) * 0.1;
                camera.position.y += (targetCameraY - camera.position.y) * 0.1;
                camera.position.z += (targetCameraZ - camera.position.z) * 0.1;
                
                // Look slightly ahead of the car based on speed
                const lookAheadX = car.position.x + speedX * 20;
                const lookAheadZ = car.position.z + speedZ * 20;
                camera.lookAt(lookAheadX, car.position.y, lookAheadZ);
            }

            // Rotate wheels based on movement
            for (let i = 0; i < 4; i++) {
                car.children[i+10].rotation.x += (speedX + speedZ) * 2;
            }
            
            // Steering animation for front wheels
            if (movingLeft || movingRight) {
                const steerAngle = speedX * 1.5;
                car.children[10].rotation.z = Math.PI/2 + steerAngle; // Front left
                car.children[11].rotation.z = Math.PI/2 + steerAngle; // Front right
            } else {
                car.children[10].rotation.z = Math.PI/2; // Front left
                car.children[11].rotation.z = Math.PI/2; // Front right
            }

            // Update stats
            distanceDisplay.textContent = Math.floor(distanceTraveled);
            const displaySpeed = Math.sqrt(speedX * speedX + speedZ * speedZ) * 50;
            speedDisplay.textContent = Math.floor(displaySpeed);
            
            // Headlight effect when moving forward fast
            if (displaySpeed > 30 && gear === 'D') {
                car.children[14].intensity = 1.5;
                car.children[15].intensity = 1.5;
            } else {
                car.children[14].intensity = 0.5;
                car.children[15].intensity = 0.5;
            }
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Create animals and birds
        createAnimals();
        createBirds();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            update();
            updateAnimals();
            updateBirds();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
          
